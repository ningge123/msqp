# 项目搭建

## 1. User服务

User服务主要是管理账号相关，比如账号的注册，积分，支付，推广等等，是http服务。

### 1.1 配置

~~~go
go get github.com/spf13/viper
~~~

viper可以读取yml，json，toml等格式的数据，常用的配置文件一般是yaml格式和json格式。

~~~go
package config

import (
	"fmt"
	"github.com/fsnotify/fsnotify"
	"github.com/spf13/viper"
	"log"
)

var Conf *Config

type Config struct {
	Log        LogConf  `mapstructure:"log"`
	Port       int      `mapstructure:"port"`
	WsPort     int      `mapstructure:"wsPort"`
	MetricPort int      `mapstructure:"metricPort"`
	HttpPort   int      `mapstructure:"httpPort"`
	AppName    string   `mapstructure:"appName"`
	Database   Database `mapstructure:"db"`
	Jwt        JwtConf  `mapstructure:"jwt"`
	Grpc       GrpcConf `mapstructure:"grpc"`
	Etcd       EtcdConf `mapstructure:"etcd"`
    Domain     map[string]Domain `mapstructure:"domain"`
    Services   map[string]ServicesConf `mapstructure:"services"`
}
type ServicesConf struct {
	Id         string `mapstructure:"id"`
	ClientHost string `mapstructure:"clientHost"`
	ClientPort int    `mapstructure:"clientPort"`
}
type Domain struct {
	Name        string `mapstructure:"name"`
	LoadBalance bool   `mapstructure:"loadBalance"`
}
type JwtConf struct {
	Secret string `mapstructure:"secret"`
	Exp    int64  `mapstructure:"exp"`
}
type LogConf struct {
	Level string `mapstructure:"level"`
}

// Database 数据库配置
type Database struct {
	MongoConf MongoConf `mapstructure:"mongo"`
	RedisConf RedisConf `mapstructure:"redis"`
}
type MongoConf struct {
	Url         string `mapstructure:"url"`
	Db          string `mapstructure:"db"`
	UserName    string `mapstructure:"userName"`
	Password    string `mapstructure:"password"`
	MinPoolSize int    `mapstructure:"minPoolSize"`
	MaxPoolSize int    `mapstructure:"maxPoolSize"`
}
type RedisConf struct {
	Addr         string   `mapstructure:"addr"`
	ClusterAddrs []string `mapstructure:"clusterAddrs"`
	Password     string   `mapstructure:"password"`
	PoolSize     int      `mapstructure:"poolSize"`
	MinIdleConns int      `mapstructure:"minIdleConns"`
	Host         string   `mapstructure:"host"`
	Port         int      `mapstructure:"port"`
}
type EtcdConf struct {
	Addrs       []string       `mapstructure:"addrs"`
	RWTimeout   int            `mapstructure:"rwTimeout"`
	DialTimeout int            `mapstructure:"dialTimeout"`
	Register    RegisterServer `mapstructure:"register"`
}
type RegisterServer struct {
	Addr    string `mapstructure:"addr"`
	Name    string `mapstructure:"name"`
	Version string `mapstructure:"version"`
	Weight  int    `mapstructure:"weight"`
	Ttl     int64  `mapstructure:"ttl"` //租约时长
}
type GrpcConf struct {
	Addr string `mapstructure:"addr"`
}

func InitConfig(configFile string) {
	Conf = new(Config)
	v := viper.New()
	v.SetConfigFile(configFile)
	v.WatchConfig()
	v.OnConfigChange(func(e fsnotify.Event) {
		log.Println("配置文件被修改")
		err := v.Unmarshal(&Conf)
		if err != nil {
			panic(fmt.Errorf("配置文件被修改以后，报错，err:%v \n", err))
		}
	})
	err := v.ReadInConfig()
	if err != nil {
		panic(fmt.Errorf("读取配置文件报错，err:%v \n", err))
	}
	if err := v.Unmarshal(&Conf); err != nil {
		panic(fmt.Errorf("Unmarshal data to Conf failed ，err:%v \n", err))
	}
}

~~~

配置文件：

~~~yml
metricPort: 5854
appName: user
log:
  level: DEBUG
grpc:
  addr: 127.0.0.1:11500
etcd:
  addrs:
    - 127.0.0.1:2379
  register:
    name: user
    addr: 127.0.0.1:11500
    version: v1
    weight: 10
    ttl: 10
db:
  mongo:
    url: mongodb://127.0.0.1:27018
    userName: root
    password: root123456
    minPoolSize: 10
    maxPoolSize: 100
    db: mschess
  redis:
    addr: 127.0.0.1:6379
    poolSize: 10
    minIdleConns: 1
    password:
jwt:
  secret: 123456
  exp: 7
~~~

### 1.2 监控

~~~shell
go get github.com/arl/statsviz@latest
~~~

可视化的go运行时指标实时图。

~~~go
package metrics

import (
	"github.com/arl/statsviz"
	"net/http"
)

// Serve 启动可视化监听指标服务 可视化图表 /debug/statsviz
func Serve(addr string) error {
	mux := http.NewServeMux()
	err := statsviz.Register(mux)
	if err != nil {
		return err
	}
	if err := http.ListenAndServe(addr, mux); err != nil {
		return err
	}
	return nil
}

~~~

~~~go
var configFile = flag.String("config", "application.yml", "config file")

func main() {
	flag.Parse()
	config.InitConfig(*configFile)
	go func() {
		err := metrics.Serve(fmt.Sprintf("0.0.0.0:%d", config.Conf.MetricPort))
		if err != nil {
			panic(err)
		}
	}()
    for{}
}
~~~

访问：`http://localhost:5854/debug/statsviz`

![image-20231121212641516](img/image-20231121212641516.png)

### 1.3 启动grpc服务

~~~go
go get google.golang.org/grpc
~~~



~~~go
var configFile = flag.String("config", "application.yml", "config file")

func main() {
	flag.Parse()
	config.InitConfig(*configFile)
	go func() {
		err := metrics.Serve(fmt.Sprintf("0.0.0.0:%d", config.Conf.MetricPort))
		if err != nil {
			panic(err)
		}
	}()
	err := app.Run(context.Background())
	if err != nil {
		log.Println(err)
		os.Exit(1)
	}
}
~~~

~~~go
package app

import (
	"common/config"
	"common/logs"
	"context"
	"google.golang.org/grpc"
	"net"
	"os"
	"os/signal"
	"syscall"
	"time"
)

func Run(ctx context.Context) error {
	server := grpc.NewServer()
	go func() {
		lis, err := net.Listen("tcp", config.Conf.Grpc.Addr)
		if err != nil {
			logs.Fatal("user grpc server listen err:%v", err)
		}
	
		logs.Info("user grpc server started listen on %s", config.Conf.Grpc.Addr)
		if err = server.Serve(lis); err != nil {
			logs.Fatal("run user grpc server failed, error : %v", err)
		}
	}()
	c := make(chan os.Signal, 1)
	stop := func() {
		server.Stop()
		time.Sleep(3 * time.Second) //给3秒时间 停止必要的服务
	}
	signal.Notify(c, syscall.SIGHUP, syscall.SIGQUIT, syscall.SIGTERM, syscall.SIGINT)
	for {
		select {
		case <-ctx.Done():
			return nil
		case s := <-c:
			logs.Warn("get a signal %s", s.String())
			switch s {
			case syscall.SIGQUIT, syscall.SIGTERM, syscall.SIGINT:
				stop()
				logs.Warn("user grpc server exit")
				return nil
			case syscall.SIGHUP:
			default:
				return nil
			}
		}
	}
}

~~~

### 1.4 日志

使用这个日志库：

~~~shell
go get github.com/charmbracelet/log@latest
~~~

~~~go
package logs

import (
	"common/config"
	"github.com/charmbracelet/log"
	"os"
	"time"
)

var logger *log.Logger

func InitLog(appName string) {
	logger = log.New(os.Stderr)
	if config.Conf.Log.Level == "DEBUG" {
		log.SetLevel(log.DebugLevel)
	} else {
		log.SetLevel(log.InfoLevel)
	}
	logger.SetPrefix(appName)
	logger.SetReportTimestamp(true)
	logger.SetTimeFormat(time.DateTime)
}

func Warn(format string, values ...any) {
	if len(values) == 0 {
		logger.Warn(format)
	} else {
		logger.Warnf(format, values...)
	}

}
func Error(format string, values ...any) {
	if len(values) == 0 {
		logger.Error(format)
	} else {
		logger.Errorf(format, values...)
	}
}
func Fatal(format string, values ...any) {
	if len(values) == 0 {
		logger.Fatal(format)
	} else {
		logger.Fatalf(format, values...)
	}
}
func Info(format string, values ...any) {
	if len(values) == 0 {
		logger.Info(format)
	} else {
		logger.Infof(format, values...)
	}

}

~~~

### 1.5 etcd注册中心

我们需要将grpc服务，注册到etcd注册中心，这样通过etcd，我们就实现了负载均衡。

~~~go
package discovery

import (
	"common/config"
	"common/logs"
	"context"
	"encoding/json"
	clientv3 "go.etcd.io/etcd/client/v3"
	"time"
)

// Register 将grpc注册到etcd
// 原理 创建一个租约 将grpc服务信息注册到etcd并且绑定租约
// 如果过了租约时间，etcd会删除存储的信息
// 可以实现心跳，完成续租，如果etcd没有则重新注册
type Register struct {
	etcdCli     *clientv3.Client                        //etcd连接
	leaseId     clientv3.LeaseID                        //租约id
	DialTimeout int                                     //超时时间 秒
	ttl         int64                                   //租约时间 秒
	keepAliveCh <-chan *clientv3.LeaseKeepAliveResponse // 心跳channel
	info        Server                                  //注册的服务信息
	closeCh     chan struct{}
}

// CreateLease 创建租约
// expire 租约时间 单位秒
func (r *Register) createLease(ctx context.Context, expire int64) error {
	grant, err := r.etcdCli.Grant(ctx, expire)
	if err != nil {
		logs.Error("CreateLease failed, error : %v", err)
		return err
	}
	r.leaseId = grant.ID
	return nil
}

// BindLease 绑定租约
func (r *Register) bindLease(ctx context.Context, key, value string) error {
	_, err := r.etcdCli.Put(ctx, key, value, clientv3.WithLease(r.leaseId))
	if err != nil {
		logs.Error("bindLease failed, error: %v", err)
		return err
	}
	return nil
}

// KeepAlive 心跳，确保服务正常
func (r *Register) keepAlive(ctx context.Context) (<-chan *clientv3.LeaseKeepAliveResponse, error) {
	resChan, err := r.etcdCli.KeepAlive(ctx, r.leaseId)
	if err != nil {
		logs.Error("bindLease failed, error: %v", err)
		return resChan, err
	}
	return resChan, nil
}

// Watcher 监听 续租 注销等
func (r *Register) watcher() {
	ticker := time.NewTicker(time.Duration(r.info.Ttl) * time.Second)
	for {
		select {
		case <-r.closeCh:
			logs.Info("stop register...")
			//注销
			if err := r.unregister(); err != nil {
				logs.Error("Stop Register,unregister failed, error:%v", err)
			}
			//撤销租约
			if _, err := r.etcdCli.Revoke(context.Background(), r.leaseId); err != nil {
				logs.Error("Stop Register,Revoke failed, error:%v", err)
			}
		case res := <-r.keepAliveCh:
			//续约
			if res == nil {
				if err := r.register(); err != nil {
					logs.Error("keepAliveCh,register failed, error:%v", err)
				}
			}
		case <-ticker.C:
			if r.keepAliveCh == nil {
				//租约到期 检查是否需要自动注册
				if err := r.register(); err != nil {
					logs.Error("ticker.C keepAliveCh==nil,register failed, error:%v", err)
				}
			}

		}
	}
}
func (r *Register) register() error {
	ctx, cancel := context.WithTimeout(context.Background(), time.Duration(r.DialTimeout)*time.Second)
	defer cancel()
	var err error
	if err = r.createLease(ctx, r.info.Ttl); err != nil {
		return err
	}
	if r.keepAliveCh, err = r.keepAlive(ctx); err != nil {
		return err
	}
	data, err := json.Marshal(r.info)
	if err != nil {
		logs.Error("etcd register json marshal error:%v", err)
		return err
	}
	return r.bindLease(ctx, r.info.BuildRegisterKey(), string(data))
}

func (r *Register) Register(conf config.EtcdConf) error {
	info := Server{
		Name:    conf.Register.Name,
		Addr:    conf.Register.Addr,
		Weight:  conf.Register.Weight,
		Version: conf.Register.Version,
		Ttl:     conf.Register.Ttl,
	}
	var err error
	if r.etcdCli, err = clientv3.New(clientv3.Config{
		Endpoints:   conf.Addrs,
		DialTimeout: time.Duration(r.DialTimeout) * time.Second,
	}); err != nil {
		return err
	}
	r.info = info
	if err = r.register(); err != nil {
		return err
	}
	r.closeCh = make(chan struct{})
	go r.watcher()
	return nil
}
func (r *Register) unregister() error {
	_, err := r.etcdCli.Delete(context.Background(), r.info.BuildRegisterKey())
	return err
}
func NewRegister() *Register {
	return &Register{
		DialTimeout: 3,
	}
}

func (r *Register) Stop() {
	r.closeCh <- struct{}{}
}

~~~

~~~go
package discovery

import (
	"encoding/json"
	"errors"
	"fmt"
	"strings"
)

type Server struct {
	Name    string `json:"name"`
	Addr    string `json:"addr"`
	Version string `json:"version"`
	Weight  int    `json:"weight"`
	Ttl     int64  `json:"ttl"`
}

func (s Server) BuildRegisterKey() string {
	if s.Version == "" {
		return fmt.Sprintf("/%s/%s", s.Name, s.Addr)
	}
	return fmt.Sprintf("/%s/%s/%s", s.Name, s.Version, s.Addr)
}

func ParseValue(val []byte) (Server, error) {
	server := Server{}
	if err := json.Unmarshal(val, &server); err != nil {
		return server, err
	}

	return server, nil
}

func ParseKey(key string) (Server, error) {
	strs := strings.Split(key, "/")
	if len(strs) == 2 {
		//no version
		return Server{
			Name: strs[0],
			Addr: strs[1],
		}, nil
	}
	if len(strs) == 3 {
		//has version
		return Server{
			Name:    strs[0],
			Version: strs[1],
			Addr:    strs[2],
		}, nil
	}
	return Server{}, errors.New("invalid key")
}

~~~

~~~go
package discovery

import (
	"common/config"
	"common/logs"
	"context"
	clientv3 "go.etcd.io/etcd/client/v3"
	"google.golang.org/grpc/attributes"
	"google.golang.org/grpc/resolver"
	"time"
)

const schema = "etcd"

type Resolver struct {
	schema      string
	etcdCli     *clientv3.Client
	closeCh     chan struct{}
	DialTimeout int
	conf        config.EtcdConf
	srvAddrList []resolver.Address
	cc          resolver.ClientConn
	key         string
	watchCh     clientv3.WatchChan
}

// Build 用于创建etcd解析器，当grpc.Dial调用时，会触发此方法
func (r *Resolver) Build(target resolver.Target, cc resolver.ClientConn, opts resolver.BuildOptions) (resolver.Resolver, error) {
	r.cc = cc
	//1. 创建etcd客户端
	var err error
	r.etcdCli, err = clientv3.New(clientv3.Config{
		Endpoints:   r.conf.Addrs,
		DialTimeout: time.Duration(r.DialTimeout) * time.Second,
	})
	if err != nil {
		logs.Fatal("connect etcd failed,err : %v", err)
	}
	r.closeCh = make(chan struct{})
	//2. 根据key获取所有服务器地址
	r.key = target.URL.Host
	if err = r.sync(); err != nil {
		return nil, err
	}
	//3. 监听 节点有变动时 更新
	go r.watch()
	return nil, nil
}

func (r *Resolver) Scheme() string {
	return r.schema
}

func (r *Resolver) Close() {
	r.closeCh <- struct{}{}
}

func (r *Resolver) watch() {
	//定时 一分钟同步一次数据
	ticker := time.NewTicker(time.Minute)
	//监听节点
	r.watchCh = r.etcdCli.Watch(context.Background(), r.key, clientv3.WithPrefix())
	for {
		select {
		case <-r.closeCh:
			logs.Info("close resolver, name=%s", r.key)
		case res, ok := <-r.watchCh:
			if ok {
				r.update(res.Events)
			}
		case <-ticker.C:
			if err := r.sync(); err != nil {
				logs.Error("resolver sync failed,err:%v", err)
			}
		}
	}
}

func (r *Resolver) sync() error {
	ctx, cancel := context.WithTimeout(context.Background(), time.Duration(r.conf.RWTimeout)*time.Second)
	defer cancel()
	res, err := r.etcdCli.Get(ctx, r.key, clientv3.WithPrefix())
	if err != nil {
		logs.Error("get etcd register service failed, name=%s, err : %v", r.key, err)
		return err
	}
	r.srvAddrList = []resolver.Address{}
	for _, v := range res.Kvs {
		server, err := ParseValue(v.Value)
		if err != nil {
			logs.Error("parse etct register service failed,name=%s, err:%v", r.key, err)
			continue
		}
		r.srvAddrList = append(r.srvAddrList, resolver.Address{
			Addr:       server.Addr,
			Attributes: attributes.New("weight", server.Weight),
		})
	}
	err = r.cc.UpdateState(resolver.State{Addresses: r.srvAddrList})
	if err != nil {
		logs.Error("updateState etcd register service failed, name=%s, err : %v", r.key, err)
		return err
	}
	return nil
}

func (r *Resolver) update(events []*clientv3.Event) {
	for _, ev := range events {
		var server Server
		var err error
		switch ev.Type {
		case clientv3.EventTypePut:
			server, err = ParseValue(ev.Kv.Value)
			if err != nil {
				logs.Error("[clientv3.EventTypePut]parse etct register service failed,name=%s, err:%v", r.key, err)
				continue
			}
			addr := resolver.Address{
				Addr:       server.Addr,
				Attributes: attributes.New("weight", server.Weight),
			}
			if !Exist(r.srvAddrList, addr) {
				r.srvAddrList = append(r.srvAddrList)
				err = r.cc.UpdateState(resolver.State{Addresses: r.srvAddrList})
				if err != nil {
					logs.Error("[clientv3.EventTypePut]updateState etcd register service failed, name=%s, err : %v", r.key, err)
				}
			}
		case clientv3.EventTypeDelete:
			server, err := ParseKey(string(ev.Kv.Key))
			if err != nil {
				logs.Error("[clientv3.EventTypeDelete] parse key, err:%v", r.key, err)
			}
			addr := resolver.Address{Addr: server.Addr}
			if list, ok := Remove(r.srvAddrList, addr); ok {
				r.srvAddrList = list
				err := r.cc.UpdateState(resolver.State{Addresses: r.srvAddrList})
				logs.Error("[clientv3.EventTypeDelete] updateState etcd register service failed, name=%s, err : %v", r.key, err)
			}
		}
	}
}

func Remove(list []resolver.Address, addr resolver.Address) ([]resolver.Address, bool) {
	for i := range list {
		if list[i].Addr == addr.Addr {
			list[i] = list[len(list)-1]
			return list[:len(list)-1], true
		}
	}
	return nil, false
}

func Exist(list []resolver.Address, addr resolver.Address) bool {
	for i := range list {
		if list[i].Addr == addr.Addr {
			return true
		}
	}
	return false
}

func NewResolver(conf config.EtcdConf) *Resolver {
	return &Resolver{
		schema:      schema,
		DialTimeout: conf.DialTimeout,
		conf:        conf,
	}
}

~~~

~~~go
logs.InitLog(config.Conf.AppName)
	register := discovery.NewRegister()
	server := grpc.NewServer()
	go func() {
		lis, err := net.Listen("tcp", config.Conf.Grpc.Addr)
		if err != nil {
			logs.Fatal("user grpc server listen err:%v", err)
		}
		////===========init db========
		//r := repo.New()
		//==========register service===============
		//pb.RegisterUserServiceServer(server, service.NewUserService(r))
		//==========register service  end ===============
		err = register.Register(config.Conf.Etcd)
		if err != nil {
			logs.Fatal("register user grpc server to etcd err: %v", err)
		}
		logs.Info("user grpc server started listen on %s", config.Conf.Grpc.Addr)
		if err = server.Serve(lis); err != nil {
			logs.Fatal("run user grpc server failed, error : %v", err)
		}
	}()
~~~

### 1.6 实现注册功能

~~~protobuf
syntax="proto3";
option go_package = "user/pb;pb";//指定生成的位置和package
message RegisterParams{
    string account = 1;
    string password = 2;
    int32 loginPlatform = 3;
    string smsCode = 4;
}

message RegisterResponse{
    string uid = 1;
}
message UserParams{
    string uid = 1;
}
message UserDTO{
    string uid = 1;
    string nickname       = 2;
    string avatar      = 3;
    string avatarFrame = 4;
    int32 sex = 5;
    int64 gold = 6;
    string emailArr = 7;
    string mobilePhone = 8;
    string realName = 9;
    bool isAgent = 10;
    string roomID = 11;
    string frontendId = 12;
    string address = 13;
    string location = 14;
    int32 isBlockedAccount = 15;
    string lastLoginIP = 16;
    int64 lastLoginTime = 17;
    int64 createTime = 18;
    repeated InviteMsg inviteMsg = 19;
}
message InviteMsg {
    int64 uid = 1;
    string nickname = 2;
    int64 unionID = 3;
    bool partner = 4;
    string unionName = 5;
}
message UnionInfo {
    int64  inviteID = 1;
    int64  unionID = 2;
    string spreaderID = 3;
    int64 score = 4;
    int64 safeScore = 5;
    bool partner = 6;
    int64 rebateRate = 7;
    int64 todayDraw = 8;
    int64 yesterdayDraw = 9;
    int64 totalDraw = 10;
    int64 weekDraw = 11;
    int64 memberTodayDraw = 12;
    int64 memberYesterdayDraw = 13;
    int64 todayBigWinDraw = 14;
    int64 yesterdayBigWinDraw = 15;
    int64 memberTodayBigWinDraw = 16;
    int64 memberYesterdayBigWinDraw = 17;
    int64 todayProvideRebate = 18;
    int64 yesterdayProvideRebate = 19;
    int64 todayRebate = 20;
    int64 yesterdayRebate = 21;
    int64 totalRebate = 22;
    int64 todayWin = 23;
    int64 yesterdayWin = 24;
    int64 prohibitGame = 25;
    int64 joinTime = 26;
}
service UserService{
  rpc Register(RegisterParams) returns(RegisterResponse);
  rpc FindUserByUid(UserParams) returns(UserDTO);
}
~~~

build.bat:

~~~shell
protoc --go_out=../pb --go_opt=paths=source_relative --go-grpc_out=../pb --go-grpc_opt=paths=source_relative  *.proto
~~~

运行，生成go代码。

#### 1.6.1 数据库连接

~~~go
package repo

import "common/database"

type Manager struct {
	Mongo *database.MongoManager
	Redis *database.RedisManager
}

func New() *Manager {
	return &Manager{
		Mongo: database.NewMongo(),
		Redis: database.NewRedis(),
	}
}

~~~

~~~go
package database

import (
	"common/config"
	"common/logs"
	"context"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"go.mongodb.org/mongo-driver/mongo/readpref"
	"time"
)

type MongoManager struct {
	Cli *mongo.Client
	Db  *mongo.Database
}

func NewMongo() *MongoManager {
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()
	clientOptions := options.Client().ApplyURI(config.Conf.Database.MongoConf.Url)
	clientOptions.SetAuth(options.Credential{
		Username: config.Conf.Database.MongoConf.UserName,
		Password: config.Conf.Database.MongoConf.Password,
	})
	clientOptions.SetMinPoolSize(uint64(config.Conf.Database.MongoConf.MinPoolSize))
	clientOptions.SetMaxPoolSize(uint64(config.Conf.Database.MongoConf.MaxPoolSize))
	client, err := mongo.Connect(ctx, clientOptions)
	if err != nil {
		logs.Fatal("mongo connect error: %v", err)
		return nil
	}
	if err := client.Ping(context.TODO(), readpref.Primary()); err != nil {
		logs.Fatal("mongo ping error: %v", err)
		return nil
	}
	m := &MongoManager{}
	m.Cli = client
	m.Db = client.Database(config.Conf.Database.MongoConf.Db)
	return m
}

func (m *MongoManager) Close() {
	err := m.Cli.Disconnect(context.TODO())
	if err != nil {
		logs.Error("mongo close error: %v", err)
	}
}

~~~

~~~go
package database

import (
	"common/config"
	"common/logs"
	"context"
	"github.com/redis/go-redis/v9"
)

type RedisManager struct {
	ClusterCli *redis.ClusterClient
	Cli        *redis.Client
}

func NewRedis() *RedisManager {
	var clusterCli *redis.ClusterClient
	var cli *redis.Client
	clusterAddrs := config.Conf.Database.RedisConf.ClusterAddrs
	if len(clusterAddrs) <= 0 {
		//单节点
		cli = redis.NewClient(&redis.Options{
			Addr:         config.Conf.Database.RedisConf.Addr,
			PoolSize:     config.Conf.Database.RedisConf.PoolSize,
			MinIdleConns: config.Conf.Database.RedisConf.MinIdleConns,
			Password:     config.Conf.Database.RedisConf.Password,
		})
	} else {
		//集群
		clusterCli = redis.NewClusterClient(&redis.ClusterOptions{
			Addrs:        config.Conf.Database.RedisConf.ClusterAddrs,
			PoolSize:     config.Conf.Database.RedisConf.PoolSize,
			MinIdleConns: config.Conf.Database.RedisConf.MinIdleConns,
			Password:     config.Conf.Database.RedisConf.Password,
		})
	}
	if clusterCli != nil {
		err := clusterCli.Ping(context.TODO()).Err()
		if err != nil {
			logs.Fatal("redis cluster ping err: %v", err)
		}
	} else {
		err := cli.Ping(context.TODO()).Err()
		if err != nil {
			logs.Fatal("redis ping err: %v", err)
		}
	}
	return &RedisManager{
		Cli:        cli,
		ClusterCli: clusterCli,
	}
}

~~~

#### 1.5.2 错误封装

~~~go
package biz

import (
	"errors"
	"framework/msError"
)

const OK = 0

var (
	Fail                        = msError.NewError(1, errors.New("请求失败"))
	RequestDataError            = msError.NewError(2, errors.New("请求数据错误"))
	SqlError                    = msError.NewError(3, errors.New("数据库操作错误"))
	InvalidUsers                = msError.NewError(4, errors.New("无效用户"))
	PermissionNotEnough         = msError.NewError(6, errors.New("权限不足"))
	SmsCodeError                = msError.NewError(7, errors.New("短信验证码错误"))
	ImgCodeError                = msError.NewError(8, errors.New("图形验证码错误")) // 图形验证码错误
	SmsSendFailed               = msError.NewError(9, errors.New("短信发送失败"))
	ServerMaintenance           = msError.NewError(10, errors.New("服务器维护"))
	NotEnoughGold               = msError.NewError(11, errors.New("钻石不足"))
	UserDataLocked              = msError.NewError(12, errors.New("用户数据被锁定"))
	NotEnoughScore              = msError.NewError(13, errors.New("积分不足"))
	AccountOrPasswordError      = msError.NewError(101, errors.New("账号或密码错误"))
	GetHallServersFail          = msError.NewError(102, errors.New("获取大厅服务器失败"))
	AccountExist                = msError.NewError(103, errors.New("账号已存在"))
	AccountNotExist             = msError.NewError(104, errors.New("帐号不存在"))
	NotFindBindPhone            = msError.NewError(105, errors.New("该手机号未绑定"))
	PhoneAlreadyBind            = msError.NewError(106, errors.New("该手机号已被绑定，无法重复绑定"))
	NotFindUser                 = msError.NewError(107, errors.New("用户不存在"))
	TokenInfoError              = msError.NewError(201, errors.New("无效的token"))
	NotEnoughVipLevel           = msError.NewError(202, errors.New("vip等级不足"))
	BlockedAccount              = msError.NewError(203, errors.New("帐号已冻结"))
	AlreadyCreatedUnion         = msError.NewError(204, errors.New("已经创建过牌友圈，无法重复创建"))
	UnionNotExist               = msError.NewError(205, errors.New("联盟不存在"))
	UserInRoomDataLocked        = msError.NewError(206, errors.New("用户在房间中，无法操作数据"))
	NotInUnion                  = msError.NewError(207, errors.New("用户不在联盟中"))
	AlreadyInUnion              = msError.NewError(208, errors.New("用户已经在联盟中"))
	InviteIdError               = msError.NewError(209, errors.New("邀请码错误"))
	NotYourMember               = msError.NewError(210, errors.New("添加的用户不是你的下级成员"))
	ForbidGiveScore             = msError.NewError(211, errors.New("禁止赠送积分"))
	ForbidInviteScore           = msError.NewError(212, errors.New("禁止玩家或代理邀请玩家"))
	CanNotCreateNewHongBao      = msError.NewError(213, errors.New("暂时无法分发新的红包"))
	CanNotLeaveRoom             = msError.NewError(305, errors.New("正在游戏中无法离开房间"))
	RoomCountReachLimit         = msError.NewError(301, errors.New("房间数量到达上线"))
	LeaveRoomGoldNotEnoughLimit = msError.NewError(302, errors.New("金币不足，无法开始游戏"))
	LeaveRoomGoldExceedLimit    = msError.NewError(303, errors.New("金币超过最大限度，无法开始游戏"))
	NotInRoom                   = msError.NewError(306, errors.New("不在该房间中"))
	RoomPlayerCountFull         = msError.NewError(307, errors.New("房间玩家已满"))
	RoomNotExist                = msError.NewError(308, errors.New("房间不存在"))
	CanNotEnterNotLocation      = msError.NewError(309, errors.New("无法进入房间，获取定位信息失败"))
	CanNotEnterTooNear          = msError.NewError(310, errors.New("无法进入房间，与房间中的其他玩家太近"))
)

~~~

~~~go
package msError

import (
	"errors"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

type Error struct {
	Code int
	Err  error
}

func (e *Error) Error() string {
	return e.Err.Error()
}

func NewError(code int, err error) *Error {
	return &Error{
		Code: code,
		Err:  err,
	}
}
func GrpcError(err *Error) error {
	return status.Error(codes.Code(err.Code), err.Err.Error())
}
func ParseGrpcError(err error) (int, string) {
	fromError, _ := status.FromError(err)
	return int(fromError.Code()), fromError.Message()
}
func ToError(err error) *Error {
	fromError, _ := status.FromError(err)
	return NewError(int(fromError.Code()), errors.New(fromError.Message()))
}

~~~



#### 1.6.3 实现

~~~go
package service

import (
	"common/biz"
	"common/config"
	"common/logs"
	"context"
	"core/dao"
	"core/models/entity"
	"core/models/requests"
	"core/repo"
	"fmt"
	biz2 "framework/msError"
	"time"
	"user/pb"
)

type AccountService struct {
	accountDao *dao.AccountDao
	redisDao   *dao.RedisDao
	pb.UnimplementedUserServiceServer
}

func NewUserService(r *repo.Manager) *AccountService {
	return &AccountService{
		accountDao: dao.NewAccount(r),
		redisDao:   dao.NewRedisDao(r),
	}
}

func (u *AccountService) Register(ctx context.Context, params *pb.RegisterParams) (*pb.RegisterResponse, error) {
	fmt.Println("===============", config.Conf.Grpc.Addr, "===============")
	if params.LoginPlatform == requests.WeiXin {
		ac, err := u.wxRegister(params)
		if err != nil {
			//这里注意转换error
			return &pb.RegisterResponse{}, biz2.GrpcError(err)
		}
		return &pb.RegisterResponse{Uid: ac.Uid}, nil
	}
	return &pb.RegisterResponse{}, nil
}
func (u *AccountService) wxRegister(param *pb.RegisterParams) (*entity.Account, *biz2.Error) {
	//微信登录 存储用户的openid即可，生成一个新的uid
	ac := &entity.Account{
		WxAccount:  param.Account,
		CreateTime: time.Now(),
	}
	uid, err := u.redisDao.NextAccountId()
	if err != nil {
		logs.Error("redis nextAccountId err:%v", err)
		return nil, biz.SqlError
	}
	ac.Uid = fmt.Sprintf("%d", uid)
	err = u.accountDao.SaveAccount(context.TODO(), ac)
	if err != nil {
		logs.Error("WxRegister accountDao SaveAccount err:%v", err)
		return nil, biz.SqlError
	}
	return ac, nil
}

~~~

~~~go
package entity

import (
	"go.mongodb.org/mongo-driver/bson/primitive"
	"time"
)

type Account struct {
	Id           primitive.ObjectID `bson:"_id,omitempty"`
	Uid          string             `bson:"uid"`
	Account      string             `bson:"account" `
	Password     string             `bson:"password"`
	PhoneAccount string             `bson:"phoneAccount"`
	WxAccount    string             `bson:"wxAccount"`
	CreateTime   time.Time          `bson:"createTime"`
}

~~~

~~~go
package requests

type LoginParams struct {
	Phone string `json:"phone"`
	Code  string `json:"code"`
	Ip    string `json:"ip,omitempty"`
}

type RegisterParams struct {
	Account       string `json:"account"`
	Password      string `json:"password,omitempty"`
	LoginPlatform int    `json:"loginPlatform"`
	SmsCode       string `json:"smsCode,omitempty"`
}

const (
	None = iota
	Account
	WeiXin
	MobilePhone
)

~~~

~~~go
package dao

import (
	"context"
	"core/models/entity"
	"core/repo"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
)

type AccountDao struct {
	repo *repo.Manager
}

func NewAccount(r *repo.Manager) *AccountDao {
	return &AccountDao{
		repo: r,
	}
}

func (d *AccountDao) FindAccount(ctx context.Context, account string) (*entity.Account, error) {
	db := d.repo.Mongo.Db.Collection("account")
	result := db.FindOne(ctx, bson.D{
		{"account", account},
	})
	ac := new(entity.Account)
	err := result.Decode(ac)
	if err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, nil
		}
		return nil, err
	}
	return ac, nil
}

func (d *AccountDao) SaveAccount(ctx context.Context, ac *entity.Account) error {
	db := d.repo.Mongo.Db.Collection("account")
	_, err := db.InsertOne(ctx, ac)
	if err != nil {
		return err
	}
	return nil
}

~~~

~~~go
package dao

import (
	"context"
	"core/repo"
)

const Prefix = "MsChess"
const (
	AccountIdRedisKey string = "AccountId"
	AccountIdBegin    int64  = 10000
	UserIdRedisKey    string = "UserId"
	UserIdBegin       int64  = 100000000
)

type RedisDao struct {
	repo *repo.Manager
}

func (d *RedisDao) NextAccountId() (int64, error) {
	return d.incr(Prefix + ":" + AccountIdRedisKey)
}
func (d *RedisDao) NextUserId() (int64, error) {
	return d.incr(Prefix + ":" + UserIdRedisKey)
}
func (d *RedisDao) incr(keyName string) (int64, error) {
	var exist int64 = 0
	var err error
	if d.repo.Redis.ClusterCli != nil {
		//集群模式
		exist, err = d.repo.Redis.ClusterCli.Exists(context.TODO(), keyName).Result()
	} else {
		exist, err = d.repo.Redis.Cli.Exists(context.TODO(), keyName).Result()
	}
	if exist == 0 {
		var value int64 = 0
		if keyName == Prefix+":"+AccountIdRedisKey {
			value = AccountIdBegin
		}
		if keyName == Prefix+":"+UserIdRedisKey {
			value = UserIdBegin
		}
		var err error = nil
		if d.repo.Redis.ClusterCli != nil {
			err = d.repo.Redis.ClusterCli.Set(context.TODO(), keyName, value, 0).Err()
		} else {
			err = d.repo.Redis.Cli.Set(context.TODO(), keyName, value, 0).Err()
		}
		if err != nil {
			return 0, err
		}
	}
	var id int64 = 0
	if d.repo.Redis.ClusterCli != nil {
		id, err = d.repo.Redis.ClusterCli.Incr(context.TODO(), keyName).Result()
	} else {
		id, err = d.repo.Redis.Cli.Incr(context.TODO(), keyName).Result()
	}
	if err != nil {
		return 0, err
	}
	return id, nil
}

func NewRedisDao(manager *repo.Manager) *RedisDao {
	return &RedisDao{
		repo: manager,
	}
}

~~~

~~~go
package dao

import (
	"context"
	"core/models/entity"
	"core/repo"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
)

type UserDao struct {
	repo *repo.Manager
}

func NewUser(r *repo.Manager) *UserDao {
	return &UserDao{
		repo: r,
	}
}

func (d *UserDao) Insert(ctx context.Context, user *entity.User) error {
	db := d.repo.Mongo.Db.Collection("user")
	_, err := db.InsertOne(ctx, user)
	if err != nil {
		return err
	}
	return nil
}

func (d *UserDao) FindUserByAccountId(ctx context.Context, id int64) (*entity.User, error) {
	db := d.repo.Mongo.Db.Collection("user")
	singleResult := db.FindOne(ctx, bson.D{
		{"accountId", id},
	})
	user := new(entity.User)
	err := singleResult.Decode(user)
	if err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, nil
		}
		return nil, err
	}
	return user, err
}

func (d *UserDao) FindUserByUid(ctx context.Context, uid string) (*entity.User, error) {
	db := d.repo.Mongo.Db.Collection("user")
	singleResult := db.FindOne(ctx, bson.D{
		{"uid", uid},
	})
	user := new(entity.User)
	err := singleResult.Decode(user)
	if err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, nil
		}
		return nil, err
	}
	return user, err
}

func (d *UserDao) UpdateUserAddressByUid(ctx context.Context, user *entity.User) error {
	db := d.repo.Mongo.Db.Collection("user")
	_, err := db.UpdateOne(ctx, bson.M{
		"uid": user.Uid,
	}, bson.M{
		"$set": bson.M{
			"address":  user.Address,
			"location": user.Location,
		},
	})
	return err
}

func (d *UserDao) FindUserByPhone(ctx context.Context, phone string) (*entity.User, error) {
	db := d.repo.Mongo.Db.Collection("user")
	singleResult := db.FindOne(ctx, bson.D{
		{"mobilePhone", phone},
	})
	user := new(entity.User)
	err := singleResult.Decode(user)
	if err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, nil
		}
		return nil, err
	}
	return user, err
}

func (d *UserDao) UpdateUserRoomByUid(ctx context.Context, user *entity.User) error {
	db := d.repo.Mongo.Db.Collection("user")
	_, err := db.UpdateOne(ctx, bson.M{
		"uid": user.Uid,
	}, bson.M{
		"$set": bson.M{
			"roomID": user.RoomID,
		},
	})
	return err
}

~~~

~~~go
package entity

import "go.mongodb.org/mongo-driver/bson/primitive"

type User struct {
	Id               primitive.ObjectID `bson:"_id,omitempty" json:"id,omitempty"`
	Uid              string             `bson:"uid" json:"uid"`
	IsBlockedAccount int                `bson:"isBlockedAccount" json:"isBlockedAccount"`
	Location         string             `bson:"location" json:"location"`
	FrontendId       string             `bson:"frontendId" json:"frontendId"`
	RoomID           string             `bson:"roomID" json:"roomID"`
	IsAgent          bool               `bson:"isAgent" json:"isAgent"`
	RealName         string             `bson:"realName" json:"realName"`
	MobilePhone      string             `bson:"mobilePhone" json:"mobilePhone"`
	InviteMsg        InviteMsg          `bson:"inviteMsg" json:"inviteMsg"`
	EmailArr         string             `bson:"emailArr" json:"emailArr"`
	Gold             int64              `bson:"gold" json:"gold"`
	UnionInfo        []*UnionInfo       `bson:"unionInfo" json:"unionInfo"`
	Sex              int                `bson:"sex" json:"sex"`
	CreateTime       int64              `bson:"createTime" json:"createTime"`
	LastLoginTime    int64              `bson:"lastLoginTime" json:"lastLoginTime"`
	LastLoginIp      string             `bson:"lastLoginIp" json:"lastLoginIp"`
	Address          string             `bson:"address" json:"address"`
	AvatarFrame      string             `bson:"avatarFrame" json:"avatarFrame"`
	Nickname         string             `bson:"nickname" json:"nickname"`
	Avatar           string             `bson:"avatar" json:"avatar"`
}

type InviteMsg struct {
	Uid       string `bson:"uid" json:"uid"`
	Nickname  string `bson:"nickname" json:"nickname"`
	UnionId   string `bson:"unionId" json:"unionId"`
	Partner   bool   `bson:"partner" json:"partner"`
	UnionName string `bson:"unionName" json:"unionName"`
}
type UnionInfo struct {
	InviteId     string `bson:"inviteId" json:"inviteId"`
	UnionID      int64  `bson:"unionID" json:"unionID"`
	Score        int    `json:"score"`
	SpreaderID   string `json:"spreaderID"`
	ProhibitGame bool   `json:"prohibitGame"`
}

const (
	Man = iota
	Woman
)

~~~

## 2. Gate服务

~~~yaml
httpPort: 13000
appName: gate
log:
  level: DEBUG
db:
  mongo:
    url: mongodb://127.0.0.1:27018
    userName: root
    password: root123456
    minPoolSize: 10
    maxPoolSize: 100
    db: mschess
  redis:
    addr: 127.0.0.1:6379
    poolSize: 10
    minIdleConns: 1
    password:
jwt:
  secret: 123456
  exp: 7
domain:
  user:
    name: user/v1
    loadBalance: true
etcd:
  addrs:
    - 127.0.0.1:2379
  rwTimeout: 3
  dialTimeout: 3
services:
  connector:
    id: connector-1
    clientHost: 127.0.0.1
    clientPort: 12000
~~~



~~~go
package main

import (
	"common/config"
	"context"
	"core/metrics"
	"flag"
	"fmt"
	"gate/app"
	"log"
	"os"
)

var configFile = flag.String("config", "application.yml", "config file")

func main() {
	flag.Parse()
	config.InitConfig(*configFile)
	go func() {
		err := metrics.Serve(fmt.Sprintf("0.0.0.0:%d", config.Conf.MetricPort))
		if err != nil {
			panic(err)
		}
	}()
	err := app.Run(context.Background())
	if err != nil {
		log.Println(err)
		os.Exit(1)
	}
}

~~~

~~~go
package app

import (
	"common/config"
	"common/logs"
	"context"
	"fmt"
	"gate/router"
	"os"
	"os/signal"
	"syscall"
)

func Run(ctx context.Context) error {
	logs.InitLog(config.Conf.AppName)
	go func() {
		r, err := router.RegisterRouter()
		if err != nil {
			logs.Fatal("user module gin register router error : %v", err)
		}
		err = r.Run(fmt.Sprintf(":%d", config.Conf.HttpPort))
		if err != nil {
			logs.Fatal("gate gin run err: %v", err)
		}
	}()
	c := make(chan os.Signal, 1)
	signal.Notify(c, syscall.SIGHUP, syscall.SIGQUIT, syscall.SIGTERM, syscall.SIGINT)
	for {
		select {
		case <-ctx.Done():
			return nil
		case s := <-c:
			logs.Warn("get a signal %s", s.String())
			switch s {
			case syscall.SIGQUIT, syscall.SIGTERM, syscall.SIGINT:
				logs.Warn("gate  exit")
				return nil
			case syscall.SIGHUP:
			default:
				return nil
			}
		}
	}
}

~~~

~~~go
package router

import (
	"common/config"
	"common/rpc"
	"gate/api"
	"github.com/gin-gonic/gin"
	"user/auth"
)

func RegisterRouter() (*gin.Engine, error) {
	if config.Conf.Log.Level == "DEBUG" {
		gin.SetMode(gin.DebugMode)
	} else {
		gin.SetMode(gin.ReleaseMode)
	}
	r := gin.Default()
	r.Use(auth.Cors())
	//========= grpc client==========
	rpc.Init()
	//===========user handler router start==============
	userHandler := api.NewUserHandler()
	r.POST("/sendCode", userHandler.SendCode)
	r.POST("/login", userHandler.Login)
	r.POST("/register", userHandler.Register)
	//===========user handler router end==============
	return r, nil
}

~~~

~~~go
package rpc

import (
	"common/config"
	"common/logs"
	"context"
	"core/discovery"
	"fmt"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/grpc/resolver"
	"user/pb"
)

var (
	UserClient pb.UserServiceClient
)

func Init() {
	r := discovery.NewResolver(config.Conf.Etcd)
	resolver.Register(r)
	domain := config.Conf.Domain["user"]
	initClient(r.Scheme(), domain.Name, domain.LoadBalance, &UserClient)

}

func initClient(scheme, name string, loadBalance bool, client interface{}) {
	addr := fmt.Sprintf("%s:///%s", scheme, name)
	opts := []grpc.DialOption{
		grpc.WithTransportCredentials(insecure.NewCredentials())}
	if loadBalance {
		opts = append(opts, grpc.WithDefaultServiceConfig(fmt.Sprintf(`{"LoadBalancingPolicy": "%s"}`, "round_robin")))
	}
	conn, err := grpc.DialContext(context.TODO(), addr, opts...)
	if err != nil {
		logs.Fatal("rpc connect etcd error: %v", err)
	}
	switch c := client.(type) {
	case *pb.UserServiceClient:
		*c = pb.NewUserServiceClient(conn)
	default:
		logs.Fatal("unsupported client type")
	}
}

~~~

~~~go
package auth

import (
	"github.com/gin-gonic/gin"
	"net/http"
)

func Cors() gin.HandlerFunc {
	return func(c *gin.Context) {
		method := c.Request.Method
		origin := c.Request.Header.Get("Origin")
		if origin != "" {
			c.Header("Access-Control-Allow-Origin", origin)
			c.Header("Access-Control-Allow-Methods", "POST, GET, PUT, DELETE, OPTIONS")
			c.Header("Access-Control-Allow-Headers", "Content-Type, Content-Length, Token")
			c.Header("Access-Control-Expose-Headers", "Access-Control-Allow-Headers, Token")
			c.Header("Access-Control-Max-Age", "172800")
			c.Header("Access-Control-Allow-Credentials", "true")
			c.Set("content-type", "application/json")
		}
		if method == "OPTIONS" {
			//c.JSON(200, Controller.R(200, nil, "Options Request"))
			c.AbortWithStatus(http.StatusNoContent)
		}
		c.Next()
	}
}

~~~

~~~go
package api

import (
	"common"
	"common/biz"
	"common/config"
	"common/jwts"
	"common/logs"
	"common/rpc"
	"context"
	biz2 "framework/msError"
	"github.com/gin-gonic/gin"
	"github.com/golang-jwt/jwt/v5"
	"time"
	"user/pb"
)

/**
用户服务处理
*/

type UserHandler struct {
}

func NewUserHandler() *UserHandler {
	return &UserHandler{}
}
func (u *UserHandler) SendCode(context *gin.Context) {
	common.Success(context, nil)
}
func (u *UserHandler) Login(ctx *gin.Context) {
}

func (u *UserHandler) Register(ctx *gin.Context) {
	var params pb.RegisterParams
	err := ctx.ShouldBindJSON(&params)
	if err != nil {
		logs.Error("Register request parse params err:%v", err)
		common.Fail(ctx, biz.RequestDataError)
		return
	}
	response, err := rpc.UserClient.Register(context.TODO(), &params)
	if err != nil {
		common.Fail(ctx, biz2.ToError(err))
	}
	//生成token 并返回connector的地址
	uid := response.Uid
	claims := jwts.CustomClaims{
		Uid: uid,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(time.Now().Add(7 * 24 * time.Hour)),
		},
	}
	token, err := jwts.GenToken(&claims, config.Conf.Jwt.Secret)
	logs.Info(token)
	result := map[string]any{
		"serverInfo": map[string]any{
			"host": config.Conf.Services["connector"].ClientHost,
			"port": config.Conf.Services["connector"].ClientPort,
		},
		"token": token,
	}
	common.Success(ctx, result)
}

~~~

~~~go
package jwts

import (
	"errors"
	"fmt"
	"github.com/golang-jwt/jwt/v5"
)

type CustomClaims struct {
	Uid string `json:"uid"`
	jwt.RegisteredClaims
}

func GenToken(claims *CustomClaims, secret string) (string, error) {
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	return token.SignedString([]byte(secret))
}

func ParseToken(token, secret string) (string, error) {
	t, err := jwt.Parse(token, func(token *jwt.Token) (interface{}, error) {
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
		}
		return []byte(secret), nil
	})
	if err != nil {
		return "", err
	}
	if claims, ok := t.Claims.(jwt.MapClaims); ok && t.Valid {
		return fmt.Sprintf("%v", claims["uid"]), nil
	}
	return "", errors.New("token not valid")
}

~~~

